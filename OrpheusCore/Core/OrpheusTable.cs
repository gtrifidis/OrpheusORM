using Microsoft.Extensions.Logging;
using OrpheusInterfaces.Core;
using OrpheusInterfaces.Interfaces.Attributes;
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel.DataAnnotations;
using System.Data;
using System.Data.Common;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text;

namespace OrpheusCore
{

    /// <summary>
    /// Represents <see cref="IOrpheusTable"/> options, which can be used to instantiate a table.
    /// </summary>
    public class OrpheusTableOptions : IOrpheusTableOptions
    {
        private IOrpheusTable masterTable;

        /// <value>
        /// Database the table belongs to.
        /// </value>
        public IOrpheusDatabase Database { get; set; }

        /// <value>
        /// List of the table's key fields. <see cref="IOrpheusTableKeyField"/>
        /// </value>
        public List<IOrpheusTableKeyField> KeyFields { get; set; }

        /// <value>
        /// Optional. A master table that this table is associated with.
        /// </value>
        public IOrpheusTable MasterTable
        {
            get
            {
                return this.masterTable;
            }
            set
            {
                this.masterTable = value;
                if (this.masterTable != null)
                {
                    this.MasterTableName = this.masterTable.SchemaName == null ? this.masterTable.Name : this.masterTable.Name.Split(".")[1];
                }
            }
        }

        /// <value>
        /// Optional. A master table that this table is associated with.
        /// </value>
        public string MasterTableName { get; set; }

        /// <value>
        /// List of the master table's keys (if master table is defined).
        /// These are being used to support a master-detail relationship.
        /// </value>
        public List<IOrpheusTableKeyField> MasterTableKeyFields { get; set; }

        /// <value>
        /// Table's model type.
        /// </value>
        [IgnoreDataMember]
        public Type ModelType { get; set; }

        /// <value>
        /// Table's name.
        /// </value>
        public string TableName { get; set; }

        /// <summary>
        /// Creates a new key field.
        /// </summary>
        /// <param name="name">Field name</param>
        /// <param name="isAutoGenerated">Auto generate flag</param>
        /// <param name="isDBGenerated">DB generated flag</param>
        /// <param name="keySQLUpdate">Function to return a custom SQL when updating the field value</param>
        public void AddKeyField(string name, bool isAutoGenerated = false, bool isDBGenerated = false, Func<string> keySQLUpdate = null)
        {
            var keyField = new OrpheusTableKeyField();
            keyField.Name = name;
            keyField.IsAutoGenerated = isAutoGenerated;
            keyField.IsDBGenerated = isDBGenerated;
            keyField.KeySQLUpdate = keySQLUpdate;
            this.KeyFields.Add(keyField);
        }

        /// <summary>
        /// Creates a new master key field
        /// </summary>
        /// <param name="name">Field name</param>
        /// <param name="isAutoGenerated">Auto generate flag</param>
        /// <param name="isDBGenerated">DB generated flag</param>
        /// <param name="keySQLUpdate">Function to return a custom SQL when updating the field value</param>
        public void AddMasterKeyField(string name, bool isAutoGenerated = false, bool isDBGenerated = false, Func<string> keySQLUpdate = null)
        {
            var keyField = new OrpheusTableKeyField();
            keyField.Name = name;
            keyField.IsAutoGenerated = isAutoGenerated;
            keyField.IsDBGenerated = isDBGenerated;
            keyField.KeySQLUpdate = keySQLUpdate;
            this.MasterTableKeyFields.Add(keyField);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="OrpheusTableOptions"/> class.
        /// </summary>
        public OrpheusTableOptions()
        {
            this.KeyFields = new List<IOrpheusTableKeyField>();
            this.MasterTableKeyFields = new List<IOrpheusTableKeyField>();
        }
    }

    #region internal classes.
    internal class ModelFieldInfo
    {
        public string Name { get; set; }
        public DbType DatabaseType { get; set; }
        public int? Size { get; set; }
    }

    /// <summary>
    /// Modified record action.
    /// </summary>
    public enum ModifiedRecordAction
    {
        /// <summary>
        /// Insert a new record.
        /// </summary>
        mraInsert,
        /// <summary>
        /// Update an existing record.
        /// </summary>
        mraUpdate,
        /// <summary>
        /// Delete an existing record.
        /// </summary>
        mraDelete
    }

    #endregion

    /// <summary>
    /// Orpheus table is the core component of an Orpheus module. Every module needs to have at least 1 table.
    /// Holds all the data of the connected table.
    /// </summary>
    /// <typeparam name="T">Model type</typeparam>
    public class OrpheusTable<T> : IOrpheusTable<T>
    {
        #region private fields
        private int level = 0;
        private IOrpheusTable masterTable;
        private List<IOrpheusTableKeyField> masterTableKeyFields;
        private bool modified = false;
        private List<T> data = new List<T>();
        private Dictionary<T, int> indexedData = new Dictionary<T, int>();
        private IDbCommand deleteCommand;
        private IDbCommand insertCommand;
        private IDbCommand updateCommand;
        private IDbCommand loadCommand;
        private IDbCommand updateAutoGeneratedKeyValues;
        private IOrpheusDatabase database;
        private List<IOrpheusTable> detailTables = new List<IOrpheusTable>();
        private bool hasAutoGeneratedKeys = false;
        private ILogger logger; 
        private List<ModelFieldInfo> fields;
        private Dictionary<T, List<KeyValuePair<string, object>>> insertCommandValues = new Dictionary<T, List<KeyValuePair<string, object>>>();
        private Dictionary<T, List<KeyValuePair<string, object>>> updateCommandValues = new Dictionary<T, List<KeyValuePair<string, object>>>();
        private Dictionary<T, List<KeyValuePair<string, object>>> deleteCommandValues = new Dictionary<T, List<KeyValuePair<string, object>>>();

        //private ConcurrentDictionary<T, ConcurrentBag<KeyValuePair<string, object>>> updateCommandValues = new ConcurrentDictionary<T, ConcurrentBag<KeyValuePair<string, object>>>();
        //private ConcurrentDictionary<T, ConcurrentBag<KeyValuePair<string, object>>> deleteCommandValues = new ConcurrentDictionary<T, ConcurrentBag<KeyValuePair<string, object>>>();
        private OrpheusModelHelper modelHelper;
        #endregion
        
        #region private methods.
        /// <summary>
        /// Properly formats a parameter name.
        /// </summary>
        /// <param name="name">Name</param>
        /// <returns></returns>
        private string getParameterName(string name)
        {
            return "@" + name;
        }

        /// <summary>
        /// Properly formats a parameter name.
        /// </summary>
        /// <param name="property">Property</param>
        /// <returns></returns>
        private string getParameterName(PropertyInfo property)
        {
            return "@" + this.modelHelper.GetFieldNameForProperty(property);
        }

        /// <summary>
        /// Properly formats a primary key parameter.
        /// </summary>
        /// <param name="name">Name</param>
        /// <returns></returns>
        private string getKeyFieldParameterName(string name)
        {
            return "@KEY_" + name;
        }

        /// <summary>
        /// Properly formats a primary key parameter.
        /// </summary>
        /// <param name="property">Property</param>
        /// <returns></returns>
        private string getKeyFieldParameterName(PropertyInfo property)
        {
            return "@KEY_" + this.modelHelper.GetFieldNameForProperty(property);
        }

        /// <summary>
        /// Iterates through the model properties and creates a list of fields for the model.
        /// </summary>
        /// <returns></returns>
        private List<ModelFieldInfo> getModelFields()
        {
            if (this.fields == null)
            {
                this.fields = new List<ModelFieldInfo>();

                this.modelHelper.IterateModelProperties((property) => {
                    //if the property is not part of the model, ignore it.
                    if (this.modelHelper.IsSchemaProperty(property))
                    {
                        var modelFieldInfo = new ModelFieldInfo()
                        {
                            Name = this.modelHelper.GetFieldNameForProperty(property),
                            DatabaseType = property.PropertyType.IsEnum ? this.database.TypeMap[typeof(int)] : this.database.TypeMap[property.PropertyType]
                        };
                        if (property.Attributes != System.Reflection.PropertyAttributes.None)
                        {
                            MaxLengthAttribute lenghAttribute = (MaxLengthAttribute)property.GetCustomAttributes().ToList().FirstOrDefault(attr => attr.GetType() == typeof(MaxLengthAttribute));
                            if (lenghAttribute != null)
                            {
                                modelFieldInfo.Size = lenghAttribute.Length;
                            }
                        }
                        this.fields.Add(modelFieldInfo);
                    }

                });
            }
            return this.fields;
        }

        /// <summary>
        /// Creates a list of editable fields. Editable fields are all model properties except those that are DB generated keys.
        /// </summary>
        /// <returns></returns>
        private List<ModelFieldInfo> getEditableFieldList()
        {
            var modelFields = this.getModelFields();
            var result = new List<ModelFieldInfo>();
            //iterating through model fields and creating a list of fields to be included
            //in the insert command.
            //Key fields that have been defined as DB generated, will not be included in the list.
            for (var i = 0; i <= modelFields.Count() - 1; i++)
            {
                ModelFieldInfo modelField = modelFields[i];
                var keyField = this.KeyFields.Find(kf => kf.Name == modelField.Name);
                var canAdd = keyField == null || (keyField != null && !keyField.IsDBGenerated);
                if (canAdd)
                {
                    result.Add(modelField);
                }
            }
            return result;
        }

        /// <summary>
        /// Returns true if the property value is empty or null
        /// </summary>
        /// <param name="property"></param>
        /// <param name="model"></param>
        /// <returns></returns>
        private bool isPropertyValueEmptyOrNull(PropertyInfo property, T model)
        {
            if(property != null)
            {
                if(property.PropertyType == typeof(System.Guid))
                {
                    return Guid.Equals(property.GetValue(model),Guid.Empty);
                }
                else
                {
                    return property.GetValue(model) == null;
                }
            }
            return true;
        }

        /// <summary>
        /// Process a record and adds master key field values if missing.
        /// </summary>
        /// <param name="record">Record</param>
        /// <param name="masterKeyValues">Key values</param>
        private void processRecordForMasterDetail(T record, List<KeyValuePair<string,object>> masterKeyValues)
        {
            if (this.masterTable != null && this.masterTableKeyFields != null)
            {
                //var masterKeyValues = this.masterTable.GetKeyValues();
                for (var i = 0; i <= this.masterTableKeyFields.Count - 1; i++)
                {
                    var masterKeyFieldName = this.masterTableKeyFields[i].Name;
                    var property = this.modelHelper.ModelProperties.FirstOrDefault(pr => pr.Name == masterKeyFieldName);
                    //if property exists in the model and it's null then
                    //set it to the master table key value.
                    if (this.isPropertyValueEmptyOrNull(property,record))
                    {
                        //the masterKeyValues list has the field names of the master table.
                        var fk = this.getMasterKeyFieldNameFromForeignKey(masterKeyFieldName);
                        if (fk == null)
                        {
                            var errorMessage = $"No foreign key was found for field {masterKeyFieldName}";
                            this.logger.LogError(errorMessage);
                            throw new NoNullAllowedException(errorMessage);
                        }
                        //property.SetValue(record, masterKeyValues.First(k=>k.Key == fk.Value.ReferenceField).Value);
                        property.SetValue(record, masterKeyValues.First(k => k.Key == fk).Value);
                    }
                }
            }
        }

        /// <summary>
        /// Returns the master key field name, that is declared in this table master table by looking up the table's
        /// foreign key list.
        /// </summary>
        /// <param name="masterTableKeyField"></param>
        /// <returns></returns>
        private string getMasterKeyFieldNameFromForeignKey(string masterTableKeyField)
        {
            var masterKey = this.modelHelper.ForeignKeys.FirstOrDefault(f => f.Value.Field == masterTableKeyField);
            if (masterKey.Value != null)
                return masterKey.Value.ReferenceField;
            return null;
        }

        /// <summary>
        /// Returns the master key field name, that is declared in this table master table by looking up the table's
        /// foreign key list.
        /// </summary>
        /// <param name="masterKeyValue"></param>
        /// <returns></returns>
        private string getMasterKeyFieldNameFromForeignKey(KeyValuePair<string,object> masterKeyValue)
        {
            return this.getMasterKeyFieldNameFromForeignKey(masterKeyValue.Key);
        }

        /// <summary>
        /// Updates auto generated key values from the DB.
        /// </summary>
        private void updateKeyValuesFromDB(T record)
        {
            List<string> keyFields = new List<string>();
            List<string> whereClause = new List<string>();
            for (var i = 0; i <= this.KeyFields.Count - 1; i++)
            {
                if (this.KeyFields[i].IsDBGenerated)
                {
                    keyFields.Add(this.KeyFields[i].Name);
                    whereClause.Add(this.KeyFields[i].KeySQLUpdate());
                }
            }
            this.updateAutoGeneratedKeyValues.CommandText = String.Format("SELECT {0} FROM {1} WHERE", String.Join(",", keyFields), Name, String.Join(",", whereClause));

            IDataReader dataReader = updateAutoGeneratedKeyValues.ExecuteReader();
            try
            {
                var fieldCount = dataReader.FieldCount;
                while (dataReader.Read())
                {
                    for (int i = 0; i <= fieldCount - 1; i++)
                    {
                        PropertyInfo propInfo = this.modelHelper.ModelProperties.FirstOrDefault(p => this.modelHelper.GetFieldNameForProperty(p) == dataReader.GetName(i));
                        if (propInfo != null)
                        {
                            var value = dataReader.GetValue(i);
                            value = value.GetType() == typeof(System.DBNull) ? null : value;
                            propInfo.SetValue(record, value);
                        }
                    }
                }
            }
            finally
            {
                dataReader.Close();
                dataReader.Dispose();
            }
        }

        private void validateParameterValue(object value)
        {
            if (value.GetType() == typeof(DateTime) && value == null)
                throw new ArgumentNullException("A date time property must have a value.");
        }


        /// <summary>
        /// Iterates through the model properties to find out primary, foreign keys.
        /// </summary>
        private void intializeModelProperties()
        {
            foreach(KeyValuePair<string,IPrimaryKey> pk in this.modelHelper.PrimaryKeys)
            {
                if (this.KeyFields.Where(kf => kf.Name.ToLower() == pk.Key.ToLower()).Count() == 0)
                {
                    var newKeyField = new OrpheusTableKeyField();
                    newKeyField.IsDBGenerated = pk.Value.IsDBGenerated;
                    newKeyField.IsAutoGenerated = pk.Value.IsAutoGenerated;
                    newKeyField.Name = pk.Key;

                    this.KeyFields.Add(newKeyField);
                }
            }

            foreach (KeyValuePair<string, IForeignKey> fk in this.modelHelper.ForeignKeys)
            {
                if (this.MasterTableKeyFields.Where(kf => kf.Name.ToLower() == fk.Key.ToLower()).Count() == 0)
                {
                    //foreign keys are not all master keys are not all  , but just the ones that belong to the master table.
                    if (this.MasterTable != null && this.MasterTable.Name.ToLower() == fk.Value.ReferenceTable.ToLower())
                    {
                        var newKeyField = new OrpheusTableKeyField();

                        newKeyField.Name = fk.Key;

                        this.MasterTableKeyFields.Add(newKeyField);
                    }
                }
            }
        }

        /// <summary>
        /// Loads table data.
        /// </summary>
        private void loadData(IDbCommand dbCommand = null)
        {
            if (dbCommand == null)
                dbCommand = this.loadCommand;
            IDataReader dataReader = null;
            try
            {
                dataReader = dbCommand.ExecuteReader();
                var fieldCount = dataReader.FieldCount;
                var fields = new List<int>();
                var properties = new List<PropertyInfo>();
                for (int i = 0; i <= fieldCount - 1; i++)
                {
                    var fldName = dataReader.GetName(i);
                    PropertyInfo propInfo = this.modelHelper.ModelProperties.FirstOrDefault(p => this.modelHelper.GetFieldNameForProperty(p) == fldName);
                    if (propInfo != null)
                    {
                        fields.Add(i);
                        properties.Add(propInfo);
                    }
                }
                while (dataReader.Read())
                {
                    T newInstance = Activator.CreateInstance<T>();
                    for (var i = 0; i <= fields.Count - 1; i++)
                    {
                        var value = dataReader.GetValue(fields[i]);
                        var property = properties[i];
                        value = value.GetType() == typeof(System.DBNull) ? null : value;
                        //special handling when the DBEngine does not support natively the Guid type and saves it
                        //as a string.
                        if (!this.database.DDLHelper.SupportsGuidType)
                        {
                            if (property.PropertyType == typeof(System.Guid) && value.GetType() == typeof(System.String))
                            {
                                value = Guid.Parse((string)value);
                            }

                        }
                        property.SetValue(newInstance, value);
                    }
                    data.Add(newInstance);
                }
            }
            catch (Exception e)
            {
                this.logger.LogError(null, e, "Error executing table load : {0}", dbCommand.CommandText);
                throw e;
            }
            finally
            {
                if (dataReader != null)
                {
                    dataReader.Close();
                    dataReader.Dispose();
                }
            }
        }

        #endregion

        #region create DbCommands
        /// <summary>
        /// Creates the delete command.
        /// </summary>
        private void createDeleteCommand()
        {
            StringBuilder sBuilder = new StringBuilder();
            sBuilder.Append(String.Format("DELETE FROM {0} WHERE ", Name));
            //all fields are enclosed within [], to avoid SQL conflicts with reserved words like "Key".
            for (var i = 0; i <= KeyFields.Count() - 1; i++)
            {
                if (i > 0)
                    sBuilder.Append(String.Format(" AND {0}{1}{2} = @KEY_{3}", 
                        this.database.DDLHelper.DelimitedIndetifierStart,
                        KeyFields[i].Name,
                        this.database.DDLHelper.DelimitedIndetifierEnd,
                        KeyFields[i].Name));
                else
                    sBuilder.Append(String.Format("{0}{1}{2} = @KEY_{3}",
                        this.database.DDLHelper.DelimitedIndetifierStart,
                        KeyFields[i].Name,
                        this.database.DDLHelper.DelimitedIndetifierEnd,
                        KeyFields[i].Name));
            }
            deleteCommand = database.CreateCommand();
            deleteCommand.CommandText = sBuilder.ToString();
            for (var i = 0; i <= KeyFields.Count() - 1; i++)
            {
                var parameter = deleteCommand.CreateParameter();
                parameter.ParameterName = this.getKeyFieldParameterName(KeyFields[i].Name);// String.Format("@KEY_{0}", KeyFields[i].Name);
                deleteCommand.Parameters.Add(parameter);
            }
            if(deleteCommand.Parameters.Count == 0)
            {
                throw new ArgumentException(String.Format("Model for table {0} has no key fields set",this.Name));
            }
        }

        /// <summary>
        /// Creates the insert command.
        /// </summary>
        private void createInsertCommand()
        {
            var editableFields = this.getEditableFieldList();
            //formating command text.
            //all fields are enclosed within [], to avoid SQL conflicts with reserved words like "Key".
            var commandText = String.Format("INSERT INTO {0} ({1}) values ({2})", Name,
                String.Join(",", (from fld in fields
                                  select String.Format("{0}{1}{2}",
                                  this.database.DDLHelper.DelimitedIndetifierStart,
                                  fld.Name,
                                  this.database.DDLHelper.DelimitedIndetifierEnd)).ToArray()),
                String.Join(",", (from fld in fields
                                  select "@" + fld.Name).ToArray()));

            insertCommand = database.CreateCommand();
            insertCommand.CommandText = commandText;

            //iterating through editable fields and adding them to the command object.
            foreach (var field in editableFields)
            {
                if (field != null)
                {
                    var param = insertCommand.CreateParameter();
                    param.ParameterName = "@" + field.Name;
                    param.DbType = field.DatabaseType;

                    if (field.Size != null)
                        param.Size = (int)field.Size;

                    insertCommand.Parameters.Add(param);
                }
            }
        }

        /// <summary>
        /// Creates the update command.
        /// </summary>
        private void createUpdateCommand()
        {
            var editableFields = this.getEditableFieldList();
            StringBuilder sBuilder = new StringBuilder();

            //creating the where clause of the update command.
            var whereClause = "";
            for (var i = 0; i <= KeyFields.Count() - 1; i++)
            {
                if (i > 0)
                    sBuilder.Append(String.Format(" AND {0} = @KEY_{1}", KeyFields[i].Name, KeyFields[i].Name));
                else
                    sBuilder.Append(String.Format("{0} = @KEY_{1}", KeyFields[i].Name, KeyFields[i].Name));
            }
            whereClause = sBuilder.ToString();
            //all fields are enclosed within [], to avoid SQL conflicts with reserved words like "Key".
            var commandText = String.Format("UPDATE {0} SET {1} WHERE {2}", Name,
                String.Join(",", fields.Select(fld => String.Format("{0}{1}{2} = {3}",
                this.database.DDLHelper.DelimitedIndetifierStart,
                fld.Name,
                this.database.DDLHelper.DelimitedIndetifierEnd,
                this.getParameterName(fld.Name)
                )).ToArray()), whereClause);

            updateCommand = database.CreateCommand();
            updateCommand.CommandText = commandText;

            //iterating through editable fields and adding them to the command object.
            foreach (var field in editableFields)
            {
                if (field != null)
                {
                    var param = updateCommand.CreateParameter();
                    param.ParameterName = this.getParameterName(field.Name);
                    param.DbType = field.DatabaseType;

                    if (field.Size != null)
                        param.Size = (int)field.Size;

                    updateCommand.Parameters.Add(param);
                }
            }

            //iterating through the key fields and creating the command parameters.
            for (var i = 0; i <= KeyFields.Count() - 1; i++)
            {
                var parameter = updateCommand.CreateParameter();
                parameter.ParameterName = this.getKeyFieldParameterName(KeyFields[i].Name);// String.Format("@KEY_{0}", KeyFields[i].Name);
                updateCommand.Parameters.Add(parameter);
            }
        }

        /// <summary>
        /// Creates the load command.
        /// </summary>
        private void createLoadCommand()
        {
            loadCommand = database.CreateCommand();
        }

        /// <summary>
        /// Appends SQL to the WHERE clause based on key values passed or if the table has a master table.
        /// </summary>
        /// <param name="keyValues"></param>
        /// <param name="logicalOperator"></param>
        private void appendSelectWhereClause(Dictionary<string,List<object>> keyValues, LogicalOperator logicalOperator)
        {
            var commandText = String.Format("SELECT * FROM {0}", Name);
            //clearing parameters to avoid duplication.
            loadCommand.Parameters.Clear();

            string logicalOperatorString = null;

            switch (logicalOperator)
            {
                case LogicalOperator.loOR: { logicalOperatorString = "OR";break; }
                case LogicalOperator.loAND: { logicalOperatorString = "AND"; break; }
                case LogicalOperator.loNOT: { logicalOperatorString = "NOT"; break; }
                default: { logicalOperatorString = "OR"; break; }
            }

            //if a table has a master table it will only load records based on the current master record.if configured correctly.
            if (this.masterTable != null && this.masterTableKeyFields != null)
            {

                var masterKeyValues = this.masterTable.GetKeyValues().ToList();
                //if there are master key values, it means that the master table has at least one record loaded.
                if (masterKeyValues.Count > 0)
                {
                    //building the master key fields SQL part.
                    var fieldsString = "";
                    var paramsPerField = new NameValueCollection();
                    //creating parameters and setting values.
                    for (var i = 0; i <= masterKeyValues.Count - 1; i++)
                    {
                        KeyValuePair<string, object> masterKeyField = masterKeyValues[i];
                        var param = loadCommand.CreateParameter();
                        param.ParameterName = $"@{masterKeyField.Key}{i}";
                        param.Value = masterKeyField.Value;
                        loadCommand.Parameters.Add(param);
                        paramsPerField.Add(masterKeyField.Key, param.ParameterName);
                    }
                    foreach (var masterKeyField in this.masterTableKeyFields)
                    {
                        //var fk = this.modelHelper.ForeignKeys.FirstOrDefault(k => k.Value.Field == masterKeyField.Name);
                        var masterKeyFieldName = this.getMasterKeyFieldNameFromForeignKey(masterKeyField.Name);
                        var parameterNames = paramsPerField.GetValues(masterKeyFieldName);

                        if (fieldsString.Length == 0)
                            fieldsString = $"{masterKeyField.Name} IN ({String.Join(",", parameterNames)})";
                        else
                        {
                            fieldsString = fieldsString + $" {logicalOperatorString} {masterKeyField.Name} IN ({String.Join(",", parameterNames)})";
                        }
                    }

                    commandText = commandText + $" WHERE {fieldsString}";

                }
                else
                {
                    //if the master key values count is zero it means that the master table has no data.
                    //if the master table has no data then neither should its detail tables.
                    commandText = $"{commandText} WHERE 0 = 1";// String.Format("{0} {1}", commandText, " 0 = 1");
                }
            }
            else
            {
                //all fields are enclosed within [], to avoid SQL conflicts with reserved words like "Key".
                if (keyValues != null)
                {
                    List<string> whereClause = new List<string>();
                    List<string> keyFieldWhereClause = new List<string>();

                    var parameterNames = new List<string>();
                    for(var i = 0; i <= keyValues.Count - 1; i++)
                    {
                        var keyFld = keyValues.ElementAt(i);
                        if (keyFld.Value != null)
                        {
                            keyFieldWhereClause.Clear();
                            for (var x = 0; x <= keyFld.Value.Count - 1; x++)
                            {
                                var paramName = $"@{keyFld.Key}_{i}_{x}";
                                var param = loadCommand.CreateParameter();
                                param.ParameterName = paramName;
                                param.Value = keyFld.Value[x];
                                loadCommand.Parameters.Add(param);
                                parameterNames.Add(paramName);
                            }
                            if(parameterNames.Count > 0)
                            {
                                if (i > 0)
                                    whereClause.Add($" {logicalOperatorString} {this.database.DDLHelper.SafeFormatField(keyFld.Key)} IN ({String.Join(",", parameterNames)})");
                                else
                                    whereClause.Add($"{this.database.DDLHelper.SafeFormatField(keyFld.Key)} IN ({String.Join(",",parameterNames)})");
                                parameterNames.Clear();
                            }
                        }
                    }
                    //if there is something in the whereClause list, then add it.
                    if (whereClause.Count > 0)
                        commandText = $"{commandText} WHERE {String.Join("", whereClause)}";// String.Format("{0} WHERE {1}", commandText, String.Join("", whereClause));
                    else
                        this.logger.LogWarning($"Warning all records will be loaded.{commandText}");
                }
            }

            loadCommand.CommandText = commandText;
        }
        #endregion
        
        #region execute Deletes
        /// <summary>
        /// Executes deletes.
        /// </summary>
        /// <param name="transaction"></param>
        protected void executeDelete(IDbTransaction transaction)
        {
            deleteCommand.Transaction = transaction;
            var commandParameters = (DbParameterCollection)this.deleteCommand.Parameters;
            foreach (var deleteRecord in this.deleteCommandValues)
            {
                foreach (var fieldValue in deleteRecord.Value)
                {
                    //((IDataParameter)this.deleteCommand.Parameters[fieldValue.Key]).Value = fieldValue.Value;
                    commandParameters[fieldValue.Key].Value = fieldValue.Value;
                }
                try
                {
                    this.deleteCommand.ExecuteNonQuery();
                }
                catch (Exception e)
                {
                    this.logger.LogError(null, e, "Error executing delete statements : {0}", this.deleteCommand.CommandText);
                    throw e;
                }
            }
            this.deleteCommandValues.Clear();
        }
        #endregion

        #region execute Updates
        /// <summary>
        /// Executes updates.
        /// </summary>
        /// <param name="transaction"></param>
        protected void executeUpdate(IDbTransaction transaction)
        {
            this.updateCommand.Transaction = transaction;
            var commandParameters = (DbParameterCollection)this.updateCommand.Parameters;
            foreach (var updateRecord in this.updateCommandValues)
            {
                foreach (var fieldValue in updateRecord.Value)
                {
                    this.validateParameterValue(fieldValue.Value);
                    //((IDataParameter)this.updateCommand.Parameters[fieldValue.Key]).Value = fieldValue.Value;
                    commandParameters[fieldValue.Key].Value = fieldValue.Value;
                }
                try
                {
                    this.updateCommand.ExecuteNonQuery();
                    //this.logger.LogTrace(this.updateCommand.CommandText);
                }
                catch (Exception e)
                {
                    this.logger.LogError(null, e, "Error executing insert statements : {0}", this.updateCommand.CommandText);
                    throw e;
                }
            }
            this.updateCommandValues.Clear();

        }

        #endregion

        #region execute Inserts
        /// <summary>
        /// Executes inserts.
        /// </summary>
        /// <param name="transaction"></param>
        protected void executeInsert(IDbTransaction transaction)
        {
            insertCommand.Transaction = transaction;
            var commandParameters = (DbParameterCollection)this.insertCommand.Parameters;
            foreach (var newRecord in this.insertCommandValues)
            {

                foreach (var fieldValue in newRecord.Value)
                {
                    this.validateParameterValue(fieldValue.Value);
                    //((IDataParameter)this.insertCommand.Parameters[fieldValue.Key]).Value = fieldValue.Value;
                    commandParameters[fieldValue.Key].Value = fieldValue.Value;
                }
                try
                {
                    this.insertCommand.ExecuteNonQuery();
                    //this.logger.LogTrace(this.insertCommand.CommandText);
                }
                catch (Exception e)
                {
                    this.logger.LogError(null, e, "Error executing insert statements : {0}", this.insertCommand.CommandText);
                    throw e;
                }
                if (this.hasAutoGeneratedKeys)
                    updateKeyValuesFromDB(newRecord.Key);
            }
            this.insertCommandValues.Clear();
        }
        #endregion

        #region processing modified records
        private object getPropertyValue(PropertyInfo property, T record)
        {
            var result = property.GetValue(record);
            result = result == null ? DBNull.Value : result;
            if (result != DBNull.Value)
            {
                var propertyType = property.PropertyType;
                if (propertyType == typeof(DateTime))
                {
                    if ((DateTime)result == DateTime.MinValue || (DateTime)result == DateTime.MaxValue)
                    {
                        result = DBNull.Value;
                    }
                }
                if(propertyType == typeof(Guid) || propertyType == typeof(Guid?))
                {
                    if (Guid.Equals(result, Guid.Empty))
                        result = DBNull.Value;
                }
            }
            return result;
        }
        private void processModifiedRecord(T modifiedRecord, ModifiedRecordAction action,int recordIndex = -1)
        {
            this.OnBeforeModify?.Invoke(this, new ModifyRecordEventArguments<T>((int)action,modifiedRecord));
            var hasKeyFields = this.KeyFields.Count() > 0;
            var newKeyListValuePair = new List<KeyValuePair<string, Object>>();
            var hasMasterTable = (this.masterTable != null && this.masterTableKeyFields != null);
            var masterKeyValues = hasMasterTable ? this.masterTable.GetKeyValues() : null;
            if (action == ModifiedRecordAction.mraInsert || action == ModifiedRecordAction.mraUpdate)
            {
                //if the table has a master table, make sure we enter the correct values in the dictionary
                //so when execute insert is ran, all foreign keys will have the correct values.
                if (hasMasterTable)
                    processRecordForMasterDetail(modifiedRecord, masterKeyValues);
                this.modelHelper.IterateModelProperties((property) => {
                    //don't set parameter values to fields/properties that are going to be generated from the DB.
                    var keyField = hasKeyFields ? this.KeyFields.Find(kf => kf.Name == property.Name) : null;
                    var canModifyRecord = keyField == null || (keyField != null && !keyField.IsDBGenerated);
                    if (canModifyRecord && this.modelHelper.IsSchemaProperty(property))
                    {
                        var paramValue = this.getPropertyValue(property,modifiedRecord);

                        if (keyField != null)
                        {
                            switch (action)
                            {
                                case ModifiedRecordAction.mraInsert:
                                    {
                                        //if a key field is set to be have an auto-generated value and is of Guid type and it does not have a value then assign a new value.
                                        if (keyField.IsAutoGenerated && property.PropertyType == typeof(System.Guid) &&  paramValue == DBNull.Value)
                                        {
                                            paramValue = Guid.NewGuid();
                                            property.SetValue(modifiedRecord, paramValue);
                                        }
                                        newKeyListValuePair.Add(new KeyValuePair<string, object>(this.getParameterName(property), paramValue));
                                        break;
                                    }
                                case ModifiedRecordAction.mraUpdate:
                                    {


                                        //if record was already loaded in memory, we need to make sure that the update
                                        //will be executed against the correct key.
                                        if (recordIndex >= 0)
                                        {
                                            var existingRecord = this.data[recordIndex];
                                            var existingKeyValue = property.GetValue(existingRecord, null);
                                            newKeyListValuePair.Add(new KeyValuePair<string, object>(this.getParameterName(property), paramValue));
                                            //if there is an update action and the key value has changed
                                            //we need to execute the update using the previous key value.
                                            if (!existingKeyValue.Equals(paramValue))
                                            {
                                                newKeyListValuePair.Add(new KeyValuePair<string, object>(this.getKeyFieldParameterName(property), existingKeyValue));
                                            }
                                            else
                                            {
                                                newKeyListValuePair.Add(new KeyValuePair<string, object>(this.getKeyFieldParameterName(property), paramValue));
                                            }
                                        }
                                        else
                                        {
                                            //this is one about updating the key field value.
                                            newKeyListValuePair.Add(new KeyValuePair<string, object>(this.getParameterName(property), paramValue));
                                            //this is will be used in the WHERE clause of the update command.
                                            //this scenario does NOT support updating the actual record's key with a new value.
                                            newKeyListValuePair.Add(new KeyValuePair<string, object>(this.getKeyFieldParameterName(property), paramValue));
                                        }
    
                                        break;
                                    }
                            }
                        }
                        else
                        {
                            //setting values for non key properties.
                            newKeyListValuePair.Add(new KeyValuePair<string, object>(this.getParameterName(property.Name), paramValue));
                        }
                    }
                });
            }

            //if action is a delete, then we do not need to iterate through all the object's properties.
            if(action == ModifiedRecordAction.mraDelete)
            {
                foreach(var keyField in this.KeyFields)
                {
                    var keyProperty = this.modelHelper.ModelProperties.Where(pf => pf.Name == keyField.Name).First();
                    if(keyProperty != null)
                    {
                        var keyValue = keyProperty.GetValue(modifiedRecord, null);
                        newKeyListValuePair.Add(new KeyValuePair<string, object>(this.getKeyFieldParameterName(keyField.Name), keyValue));
                    }
                }
            }
            switch (action)
            {
                case ModifiedRecordAction.mraInsert:
                    {
                        if (this.insertCommandValues.ContainsKey(modifiedRecord))
                            this.insertCommandValues[modifiedRecord] = newKeyListValuePair;
                        else
                            this.insertCommandValues.Add(modifiedRecord, newKeyListValuePair);
                        break;
                    }
                case ModifiedRecordAction.mraUpdate:
                    {
                        if (this.updateCommandValues.ContainsKey(modifiedRecord))
                            this.updateCommandValues[modifiedRecord] = newKeyListValuePair;
                        else
                            this.updateCommandValues.Add(modifiedRecord, newKeyListValuePair);
                        break;
                    }
                case ModifiedRecordAction.mraDelete:
                    {
                        if (this.deleteCommandValues.ContainsKey(modifiedRecord))
                            this.deleteCommandValues[modifiedRecord] = newKeyListValuePair;
                        else
                            this.deleteCommandValues.Add(modifiedRecord, newKeyListValuePair);
                        break;
                    }
            }
            this.OnAfterModify?.Invoke(this, new ModifyRecordEventArguments<T>((int)action,modifiedRecord));
        }
        #endregion

        #region constructors
        /// <summary>
        /// Orpheus table constructor.
        /// </summary>
        /// <param name="database" cref="IOrpheusDatabase">Orpheus database</param>
        /// <param name="tableName">Table name</param>
        /// <param name="keyFields">Table key fields.</param>
        /// <param name="masterTable" cref="IOrpheusTable">Master table (optional)</param>
        /// <param name="masterTableKeyFields" cref="List{IOrpheusTableKeyField}">Master table key fields (optional)</param>
        public OrpheusTable(IOrpheusDatabase database,List<IOrpheusTableKeyField> keyFields, string tableName = null, IOrpheusTable masterTable = null, List<IOrpheusTableKeyField> masterTableKeyFields=null)
        {
            this.logger = ServiceProvider.OrpheusServiceProvider.Resolve<ILogger>();
            this.database = database;
            this.Name = tableName;
            this.KeyFields = keyFields;
            this.hasAutoGeneratedKeys = this.KeyFields.FindAll(key => key.IsDBGenerated == true).Count > 0;
            if (this.hasAutoGeneratedKeys)
                this.updateAutoGeneratedKeyValues = this.database.CreateCommand();
            this.masterTable = masterTable;
            this.masterTableKeyFields = masterTableKeyFields;
            if (this.masterTableKeyFields == null)
                this.masterTableKeyFields = new List<IOrpheusTableKeyField>();
            if (this.masterTable != null)
            {
                this.level = this.masterTable.Level + 1;
                this.masterTable.DetailTables.Add(this);
            }

            this.modelHelper = new OrpheusModelHelper(typeof(T));
            this.SchemaName = this.modelHelper.SQLServerSchemaName;

            if (this.Name != null && (this.Name.ToLower() != this.modelHelper.SQLName.ToLower()))
                this.logger.LogWarning($"The table name {this.Name} passed into the constructor is not the same as the associated model's {this.modelHelper.SQLName}");

            //if there is no table name defined in the constructor but
            //there is a table-name attribute on the model, then use that as the table name
            if (this.Name == null && this.modelHelper.SQLName != null)
                this.Name = this.modelHelper.SQLName;
            
            if(this.Name == null)
            {
                var errorMessage = "Table name cannot be null.";
                this.logger.LogError(errorMessage);
                throw new ArgumentNullException(errorMessage);
            }
                

            //if there is a schema name defined (through the model attribute) but the current table name doesn't start with/contain the schema name, then set it.
            if(this.SchemaName != null && (!this.Name.ToLower().Contains($"{this.SchemaName.ToLower()}.")))
            {
                this.Name = $"{this.SchemaName}.{this.Name}";
            }

            //if (this.modelHelper.SQLName == null && this.modelHelper.SQLServerSchemaName != null && !this.Name.Contains(this.modelHelper.SQLServerSchemaName+"."))
            //{
            //    this.Name = String.Format("{0}.{1}", this.modelHelper.SQLServerSchemaName, tableName);
            //}

            this.intializeModelProperties();
            this.createDeleteCommand();
            this.createUpdateCommand();
            this.createInsertCommand();
            this.createLoadCommand();
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="OrpheusTable{T}"/> class.
        /// </summary>
        /// <param name="options">The options.</param>
        public OrpheusTable(IOrpheusTableOptions options):this(options.Database,options.KeyFields, options.TableName, options.MasterTable, options.MasterTableKeyFields)
        {
        }
        #endregion

        #region public methods        
        /// <summary>
        /// Executes any delete changes that the table has.
        /// </summary>
        /// <param name="transaction">The transaction.</param>
        public void ExecuteDeletes(IDbTransaction transaction)
        {
            this.executeDelete(transaction);
        }

        /// <summary>
        /// Executes any update changes that the table has.
        /// </summary>
        /// <param name="transaction">The transaction.</param>
        public void ExecuteUpdates(IDbTransaction transaction)
        {
            this.executeUpdate(transaction);
        }

        /// <summary>
        /// Executes any insert changes that the table has.
        /// </summary>
        /// <param name="transaction">The transaction.</param>
        public void ExecuteInserts(IDbTransaction transaction)
        {
            this.executeInsert(transaction);
        }

        /// <summary>
        /// Loads records from the DB to the table.
        /// </summary>
        /// <param name="keyValues">The key values.</param>
        /// <param name="clearExistingData">If true, it will clear all existing data. Default is true.</param>
        /// <exception cref="InvalidExpressionException">When an Orpheus table has more than one key fields, you cannot use the 'simple' load. Values for each field much be determined.</exception>
        public void Load(List<object> keyValues = null, bool clearExistingData = true)
        {
            if (this.KeyFields.Count == 1)
            {
                this.Load(new Dictionary<string, List<object>>() {
                    {
                        this.KeyFields.First().Name,
                        keyValues
                    }
                }, LogicalOperator.loOR,clearExistingData);
            }
            else
                throw new InvalidExpressionException("When an Orpheus table has more than one key fields, you cannot use the 'simple' load. Values for each field much be determined.");
        }

        /// <summary>
        /// Loads records from the DB to the table.
        /// You can configure having multiple fields and multiple values per field.
        /// Multiple field values are bound with a logical OR.
        /// Multiple fields by default are bound with a logical OR.
        /// Defining a logical operator, you can change the default behavior.
        /// </summary>
        /// <param name="keyValues">The key values.</param>
        /// <param name="logicalOperator">The logical operator.</param>
        /// <param name="clearExistingData">If true, it will clear all existing data. Default is true.</param>
        public void Load(Dictionary<string, List<object>> keyValues = null, LogicalOperator logicalOperator = LogicalOperator.loOR, bool clearExistingData = true)
        {
            if (clearExistingData)
                this.ClearData();
            this.appendSelectWhereClause(keyValues, logicalOperator);
            this.loadData();
        }

        /// <summary>
        /// Loads table data by executing a SQL command.
        /// </summary>
        /// <param name="SQL">SQL command to be executed</param>
        /// <param name="clearExistingData">If true, it will clear all existing data. Default is true.</param>
        public void Load(string SQL, bool clearExistingData = true)
        {
            if (clearExistingData)
                this.ClearData();
            this.loadCommand.CommandText = SQL;
            this.loadData();
        }

        /// <summary>
        /// Loads table data by executing a db command.
        /// </summary>
        /// <param name="dbCommand">The IDbCommand instance.</param>
        /// <param name="clearExistingData">If true, it will clear all existing data. Default is true.</param>
        public void Load(IDbCommand dbCommand, bool clearExistingData = true)
        {
            if (clearExistingData)
                this.ClearData();
            this.loadData(dbCommand);
        }

        /// <summary>
        /// Clears existing loaded data.
        /// </summary>
        public void ClearData()
        {
            this.data.Clear();
            this.indexedData.Clear();
        }

        /// <value>
        /// Table's currently loaded data.
        /// </value>
        public List<T> Data
        {
            get
            {
                var result = new List<T>();
                result.AddRange(data);
                return result;
            }
        }

        /// <value>
        /// Table name.
        /// </value>
        public string Name { get; set; }

        /// <value>
        /// The table's schema name. Applicable only if the db engine is SQL Server.
        /// </value>
        public string SchemaName { get; private set; }

        /// <value>
        /// Table key fields.
        /// </value>
        public List<IOrpheusTableKeyField> KeyFields { get; set; }

        /// <value>
        /// Table master table's key fields.
        /// </value>
        public List<IOrpheusTableKeyField> MasterTableKeyFields
        {
            get
            {
                return this.masterTableKeyFields;
            }
        }

        /// <value>
        /// Associated master table.
        /// </value>
        public IOrpheusTable MasterTable
        {
            get
            {
                return masterTable;
            }
            set
            {
                //if the new value is null, but the previous not,
                //remove this table from the list of detail tables
                //of the masterTable.
                if(value == null && this.masterTable != null)
                {
                    if (this.masterTable.DetailTables.Contains(this))
                        this.masterTable.DetailTables.Remove(this);
                }
                masterTable = value;
                if (this.masterTable != null)
                {
                    this.level = this.masterTable.Level + 1;
                    if (!this.masterTable.DetailTables.Contains(this))
                        this.masterTable.DetailTables.Add(this);
                }
            }
        }

        /// <value>
        /// Associated detail tables.
        /// </value>
        public List<IOrpheusTable> DetailTables
        {
            get
            {
                return this.detailTables;
            }
        }

        /// <value>
        /// Table level.
        /// </value>
        public int Level
        {
            get
            {
                return level;
            }
        }

        /// <value>
        /// Returns list of currently loaded key values. It's purpose is to be used on a master-detail schema
        /// where this will be used from the detail tables in order to load their data based on the current master record.
        /// It's highly inadvisable to be used outside this scope.
        /// </value>
        /// <returns></returns>
        public List<KeyValuePair<string,object>> GetKeyValues()
        {
            var result = new List<KeyValuePair<string, object>>();
            foreach (T record in data)
            {
                for (var i = 0; i <= this.modelHelper.ModelProperties.Count() - 1; i++)
                {
                    PropertyInfo property = this.modelHelper.ModelProperties[i];
                    var keyField = this.KeyFields.Find(kf => kf.Name == property.Name);
                    if(keyField != null)
                    {
                        result.Add(new KeyValuePair<string, object>(keyField.Name,property.GetValue(record)));
                    }
                }
            }
            return result;
        }

        /// <value>
        /// Modified flag.
        /// </value>
        public bool Modified
        {
            get
            {
                return modified;
            }
        }

        /// <summary>
        /// Adds a new record to the table.
        /// </summary>
        /// <param name="newRecord">New record to be added</param>
        public void Add(T newRecord)
        {
            this.data.Add(newRecord);
            this.indexedData.Add(newRecord, this.data.Count - 1);
            this.processModifiedRecord(newRecord,ModifiedRecordAction.mraInsert);
            this.modified = true;
        }

        /// <summary>
        /// Adds a list of new records.
        /// </summary>
        /// <param name="newRecords">New records to be added</param>
        public void Add(List<T> newRecords)
        {
            foreach (var rec in newRecords)
                this.Add(rec);
        }

        /// <summary>
        /// Deletes a record.
        /// </summary>
        /// <param name="record">Record to delete</param>
        public void Delete(T record)
        {
            if (this.indexedData.ContainsKey(record))
            {
                this.data.RemoveAt(this.indexedData[record]);
                this.indexedData.Remove(record);
            }
            //this.data.Remove(record);
            this.processModifiedRecord(record, ModifiedRecordAction.mraDelete);
            this.modified = true;
        }

        /// <summary>
        /// Deletes records.
        /// </summary>
        /// <param name="records">Records to be deleted</param>
        public void Delete(List<T> records)
        {
            foreach (var rec in records)
                this.Delete(rec);
        }

        /// <summary>
        /// Updates an existing record.
        /// </summary>
        /// <param name="record">Record to be updated</param>
        public void Update(T record)
        {
            var idx = -1;
            if (this.indexedData.ContainsKey(record))
            {
                idx = this.indexedData[record];
                //if the record was already loaded in memory, update it as well.
                if (idx >= 0)
                    this.data[idx] = record;
            }
            this.processModifiedRecord(record, ModifiedRecordAction.mraUpdate, idx);
        }

        /// <summary>
        /// Updates existing records.
        /// </summary>
        /// <param name="records">Records to be updated</param>
        public void Update(List<T> records)
        {
            foreach (var rec in records)
                this.Update(rec);
        }

        /// <summary>
        /// Save changes to the database.
        /// </summary>
        /// <param name="dbTransaction">Transaction in which the commands will be executed</param>
        /// <param name="commitTransaction">Commit transaction after save.</param>
        public void Save(IDbTransaction dbTransaction = null, bool commitTransaction = true)
        {
            var transaction = dbTransaction == null ? this.database.BeginTransaction() : dbTransaction;
            this.OnBeforeSave?.Invoke(this, new SaveEventArguments() { Transaction = transaction });
            try
            {
                this.executeDelete(transaction);
                this.executeUpdate(transaction);
                this.executeInsert(transaction);
                if(commitTransaction)
                    this.database.CommitTransaction(transaction);
                this.OnAfterSave?.Invoke(this, new SaveEventArguments() { Transaction = transaction });
            }
            catch (Exception exception)
            {
                //if transaction was committed then roll it back.
                if(commitTransaction)
                    this.database.RollbackTransaction(transaction);
                this.logger.LogError(exception.Message);
                throw exception;
            }
        }

        /// <value>
        /// Occurs before records are save in the database.
        /// </value>
        public event EventHandler<ISaveEventArguments> OnBeforeSave;

        /// <value>
        /// Occurs after the transaction has been committed.
        /// </value>
        public event EventHandler<ISaveEventArguments> OnAfterSave;

        /// <value>
        /// Occurs before a table modifies a record. It is fired on any Add,Update,Delete
        /// </value>
        public event EventHandler<IModifyRecordEventArguments<T>> OnBeforeModify;

        /// <value>
        /// Occurs after a table modifies a record. It is fired on any Add,Update,Delete
        /// </value>
        public event EventHandler<IModifyRecordEventArguments<T>> OnAfterModify;

        #endregion
    }
}



